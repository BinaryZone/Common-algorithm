package com.wh.datastructure.sort;

import java.util.Arrays;

/**
 * 快速排序
 * T(n) = O(n**2)
 * S(n) = O(logn)
 * @author DELL
 *
 */
public class TestQuickSort {
	public static void main(String[] args) {
		//给出无序数组
		int arr[] = {72,6,57,88,60,42,83,73,48,85};
		
		//输出无序数组
		System.out.println(Arrays.toString(arr));
		//快速排序
		quickSort(arr);
		
		//输出有序数组
		System.out.println(Arrays.toString(arr));
	}

	private static void quickSort(int[] arr) {
		int low = 0;
		int high = arr.length - 1;
		quickSort(arr,low,high);
		
	}

	private static void quickSort(int[] arr, int low, int high) {
		if (low<high) {
			//分区操作，将数组分为两个分区，并返回分区界限索引
		int index = partition(arr,low,high);
		
		//对左分区快速排序
		quickSort(arr, low, index-1);
		
		//对右分区快速排序
		quickSort(arr, index+1, high);
		}
		
		
	}

	private static int partition(int[] arr, int low, int high) {
		// 指定左指针i和右指针j
		int i = low;
		int j = high;
		
		// 将第一个值作为基准值，挖坑
		int x = arr[low];
		
		// 使用循环实现分区操作
		while(i<j) {
			//从右往左移动j，找到第一个小于基准值的值arr[j]
			while(arr[j]>=x && i<j) {
				j--;
			}
			//将右侧找到小于基准数的值加入到左边的坑位置，左指针向中间移动一个位置i++
			if (i<j) {
				arr[i] = arr[j];
				i++;
			}
			
			//从左向右移动i，找到第一个大于等于基准值的值arr[i]
			while(arr[i]<x && i<j) {
				i++;
			}
			
			//将左侧找到的大于等于基准值的值加入到右边的坑中，右指针向中间移动一个位置，j--
			if (i<j) {
				arr[j] = arr[i];
				j--;
			}
		}
		
		// 使用基准值填坑，这就是基准值的最终位置
		arr[i] = x; //arr[j] = y;
		
		//返回基准值的位置索引
		return i;  //return j;
		
	}
}
